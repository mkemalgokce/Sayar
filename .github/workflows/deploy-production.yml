name: Deploy to Production

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

# Prevent concurrent deployments
concurrency:
  group: deploy-production-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: macos-26

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify tag is from master branch
        run: |
          set -e
          # Get the branch that contains this tag
          BRANCHES=$(git branch -r --contains ${{ github.ref }})
          echo "Branches containing this tag: $BRANCHES"

          if echo "$BRANCHES" | grep -q "origin/master"; then
            echo "✅ Tag is on master branch"
          else
            echo "❌ Tag must be created from master branch"
            echo "   Current branches: $BRANCHES"
            exit 1
          fi

      - name: Cache Homebrew
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/Homebrew
            /opt/homebrew/Cellar/git-cliff
            /opt/homebrew/Cellar/libgit2
            /opt/homebrew/Cellar/tuist
          key: ${{ runner.os }}-brew-deploy-${{ hashFiles('.github/workflows/deploy-production.yml') }}
          restore-keys: |
            ${{ runner.os }}-brew-deploy-
            ${{ runner.os }}-brew-

      - name: Cache Tuist
        uses: actions/cache@v4
        with:
          path: |
            ~/.tuist
            Tuist/.build
          key: ${{ runner.os }}-tuist-${{ hashFiles('**/Project.swift', 'Tuist/Package.swift') }}
          restore-keys: |
            ${{ runner.os }}-tuist-

      - name: Install git-cliff
        run: |
          brew install git-cliff
          brew link --overwrite git-cliff
          brew link --overwrite libgit2

      - name: Install Tuist
        run: |
          brew install tuist
          tuist version

      - name: Install dependencies
        run: |
          tuist install

      - name: Setup Firebase config
        env:
          FIREBASE_CONFIG_PROD: ${{ secrets.FIREBASE_CONFIG_PROD }}
        run: |
          mkdir -p App/Resources/Firebase
          echo "$FIREBASE_CONFIG_PROD" | base64 --decode > App/Resources/Firebase/GoogleService-Info-Prod.plist

      - name: Generate Tuist project
        run: |
          tuist generate

      - name: Get version from tag
        id: version
        run: |
          # Extract version from tag (v1.2.3 -> 1.2.3)
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "📦 Version from tag: $VERSION"

          # Validate semantic versioning format
          if ! [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ Invalid version format: $VERSION"
            echo "   Expected format: v1.2.3 (semantic versioning)"
            exit 1
          fi

          echo "✅ Version format validated"

      - name: Validate CHANGELOG and check for changes
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          # Check if there are unreleased changes
          UNRELEASED_CHANGES=$(git-cliff --config .github/cliff/cliff.toml --unreleased --strip all)

          if [ -z "$UNRELEASED_CHANGES" ]; then
            echo "❌ No unreleased changes found in CHANGELOG"
            echo "   Cannot create release without changes"
            echo "   Please make sure you have commits since the last release"
            exit 1
          fi

          echo "✅ Found unreleased changes:"
          echo "$UNRELEASED_CHANGES"

      - name: Check if tag already deployed to TestFlight
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          # Check if CHANGELOG already contains this version
          if grep -q "## \[${VERSION}\]" CHANGELOG.md 2>/dev/null; then
            echo "⚠️  Warning: Version ${VERSION} already exists in CHANGELOG"
            echo "   This might be a re-deployment or the tag was created before"
          else
            echo "✅ Version ${VERSION} is new"
          fi

      - name: Check if this is a new version or rebuild
        id: version_check
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -e
          # Check remote CHANGELOG on master branch to determine if this is a rebuild
          git fetch origin master

          if git show origin/master:CHANGELOG.md 2>/dev/null | grep -q "## \[${VERSION}\]"; then
            echo "is_rebuild=true" >> $GITHUB_OUTPUT
            echo "⚠️  Version ${VERSION} already exists in remote CHANGELOG - this is a REBUILD"
          else
            echo "is_rebuild=false" >> $GITHUB_OUTPUT
            echo "✅ New version ${VERSION}"
          fi

      - name: Generate release notes for GitHub
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -e
          # Generate GitHub release notes (Markdown, only important commits)
          # Don't update CHANGELOG.md yet - wait until deployment succeeds
          git-cliff --config .github/cliff/cliff-release.toml --unreleased --tag "v${VERSION}" --strip all > $RUNNER_TEMP/release-notes.md

          # Check if release notes are empty
          if [ ! -s $RUNNER_TEMP/release-notes.md ] || [ $(wc -l < $RUNNER_TEMP/release-notes.md) -lt 2 ]; then
            echo "No significant user-facing changes in this release." > $RUNNER_TEMP/release-notes.md
          fi

          echo "✅ Release notes generated"

      - name: Get and prepare build number
        id: build_number
        env:
          VERSION: ${{ steps.version.outputs.version }}
          IS_REBUILD: ${{ steps.version_check.outputs.is_rebuild }}
        run: |
          # Get current Prod build number
          CURRENT_BUILD=$(grep "CURRENT_PROJECT_VERSION_PROD" Config/BuildNumbers.xcconfig | awk '{print $3}')

          if [ "$IS_REBUILD" == "true" ]; then
            # Same version, increment build number
            NEW_BUILD=$(expr $CURRENT_BUILD + 1)
            echo "📦 Rebuild detected - incrementing build: $CURRENT_BUILD -> $NEW_BUILD"
          else
            # New version, reset build number to 1
            NEW_BUILD=1
            echo "📦 New version - resetting build number to 1"
          fi

          # Update Prod build number in BuildNumbers.xcconfig
          sed -i '' "s/CURRENT_PROJECT_VERSION_PROD = .*/CURRENT_PROJECT_VERSION_PROD = $NEW_BUILD/" Config/BuildNumbers.xcconfig

          echo "current_build=$CURRENT_BUILD" >> $GITHUB_OUTPUT
          echo "new_build=$NEW_BUILD" >> $GITHUB_OUTPUT

      - name: Select Xcode version
        run: sudo xcode-select -switch /Applications/Xcode_26.0.app

      - name: Show Xcode version
        run: /usr/bin/xcodebuild -version

      - name: Create temporary keychain
        env:
          CERTIFICATE_P12: ${{ secrets.CERTIFICATE_P12 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "$CERTIFICATE_P12" | base64 --decode > certificate.p12
          security import certificate.p12 -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"

      - name: Install provisioning profile
        env:
          PROVISIONING_PROFILE: ${{ secrets.PROVISIONING_PROFILE }}
        run: |
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          echo "$PROVISIONING_PROFILE" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision

      - name: Build and archive
        env:
          DEVELOPMENT_TEAM: ${{ secrets.DEVELOPMENT_TEAM }}
          PROVISIONING_PROFILE_SPECIFIER: ${{ secrets.PROVISIONING_PROFILE_SPECIFIER }}
        run: |
          xcodebuild clean archive \
            -workspace Sayar.xcworkspace \
            -scheme "Sayar Prod" \
            -configuration Prod \
            -archivePath $RUNNER_TEMP/Sayar.xcarchive \
            -destination 'generic/platform=iOS' \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM=$DEVELOPMENT_TEAM \
            PROVISIONING_PROFILE_SPECIFIER="$PROVISIONING_PROFILE_SPECIFIER" \
            DEBUG_INFORMATION_FORMAT=dwarf-with-dsym

      - name: Export IPA
        run: |
          xcodebuild -exportArchive \
            -archivePath $RUNNER_TEMP/Sayar.xcarchive \
            -exportPath $RUNNER_TEMP/export \
            -exportOptionsPlist .github/deployment/ExportOptions-Prod.plist

      - name: Setup App Store Connect API key
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY_CONTENT }}
        run: |
          mkdir -p ~/.appstoreconnect/private_keys
          echo "$APP_STORE_CONNECT_API_KEY_CONTENT" | base64 --decode > ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

      - name: Upload to TestFlight
        id: testflight_upload
        shell: bash
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -e  # Exit on any error

          echo "📤 Validating IPA..."
          if xcrun altool --validate-app -f $RUNNER_TEMP/export/Sayar.ipa -t ios --apiKey $APP_STORE_CONNECT_API_KEY_ID --apiIssuer $APP_STORE_CONNECT_ISSUER_ID --use-old-altool; then
            echo "✅ IPA validation successful"
          else
            echo "❌ IPA validation failed"
            exit 1
          fi

          echo "📤 Uploading to TestFlight..."
          if xcrun altool --upload-app -f $RUNNER_TEMP/export/Sayar.ipa -t ios --apiKey $APP_STORE_CONNECT_API_KEY_ID --apiIssuer $APP_STORE_CONNECT_ISSUER_ID --use-old-altool; then
            echo "✅ TestFlight upload successful"
          else
            echo "❌ TestFlight upload failed"
            exit 1
          fi

      - name: Create GitHub Release
        if: success()
        env:
          VERSION: ${{ steps.version.outputs.version }}
          BUILD: ${{ steps.build_number.outputs.new_build }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if release already exists
          if gh release view "v${VERSION}" &>/dev/null; then
            echo "ℹ️ Release v${VERSION} already exists - updating notes"
            gh release edit "v${VERSION}" \
              --notes-file $RUNNER_TEMP/release-notes.md \
              --title "v${VERSION} (Build ${BUILD})"
          else
            echo "✅ Creating new release v${VERSION}"
            gh release create "v${VERSION}" \
              --notes-file $RUNNER_TEMP/release-notes.md \
              --title "v${VERSION}" \
              --target master
          fi

          echo "✅ GitHub Release created/updated for v${VERSION}"

      - name: Commit CHANGELOG and build number after successful deployment
        if: success()
        env:
          VERSION: ${{ steps.version.outputs.version }}
          BUILD: ${{ steps.build_number.outputs.new_build }}
        run: |
          set -e  # Exit on error

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Fetch latest master to avoid conflicts
          git fetch origin master
          git rebase origin/master || {
            echo "❌ Failed to rebase with remote changes"
            git rebase --abort
            exit 1
          }

          # NOW generate CHANGELOG after successful deployment
          git-cliff --config .github/cliff/cliff.toml --unreleased --tag "v${VERSION}" --prepend CHANGELOG.md

          # Add both CHANGELOG and BuildNumbers.xcconfig
          git add CHANGELOG.md Config/BuildNumbers.xcconfig

          if ! git diff --staged --quiet; then
            git commit -m "chore(release): update CHANGELOG and build number for v${VERSION} (Build ${BUILD}) [skip ci]"

            # Push with retry logic
            for i in {1..3}; do
              if git push origin HEAD:master; then
                echo "✅ CHANGELOG and build number updated for v${VERSION} (Build ${BUILD})"
                break
              else
                echo "⚠️ Push failed, retrying ($i/3)..."
                sleep 2
                git fetch origin master
                git rebase origin/master
              fi

              if [ $i -eq 3 ]; then
                echo "❌ Failed to push after 3 attempts"
                exit 1
              fi
            done
          else
            echo "ℹ️ No changes to commit"
          fi

      - name: Update marketing version in develop branch
        if: success() && steps.version_check.outputs.is_rebuild == 'false'
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -e  # Exit on error

          # Fetch and checkout latest develop branch
          git fetch origin develop
          git checkout -b temp-version-update origin/develop

          # Update marketing version in Base.xcconfig
          sed -i '' "s/MARKETING_VERSION = .*/MARKETING_VERSION = $VERSION/" Config/Base.xcconfig

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Commit and push if there are changes
          git add Config/Base.xcconfig
          if ! git diff --staged --quiet; then
            git commit -m "chore(version): update marketing version to $VERSION [skip ci]"

            # Push with retry logic
            for i in {1..3}; do
              if git push origin temp-version-update:develop; then
                echo "✅ Marketing version updated to $VERSION in develop branch"
                break
              else
                echo "⚠️ Push failed, retrying ($i/3)..."
                sleep 2
                git fetch origin develop
                git rebase origin/develop
              fi

              if [ $i -eq 3 ]; then
                echo "❌ Failed to push version update after 3 attempts"
                # Don't fail the whole workflow for this
                echo "⚠️ Manual version update required in develop branch"
              fi
            done
          else
            echo "ℹ️ Marketing version already up to date in develop"
          fi

      - name: Clean up keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
